#!/bin/sh /etc/rc.common

START=18
STOP=90

USE_PROCD=1

PAM_DIR="/var/run/pamd/pam.d"
RADIUS_DIR="/var/run/pamd/raddb"
ENABLED=0

PROG=/usr/sbin/pamd
[ -x "$PROG" ] || PROG="/usr/local$PROG"

radius_pam_conf() {
	local var="$1" sec="$2" external_users="$3"
	local server secret port timeout additional

	config_get server "$sec" server
	config_get secret "$sec" secret
	config_get port "$sec" port 1812
	config_get timeout "$sec" timeout 3
	config_get require_message_auth "$sec" require_message_auth

	[ "$external_users" -eq 1 ] && additional=" privilege_level localifdown"

	[ -z "$server" ] || [ -z "$secret" ] && {
		logger -t pam "Radius server ip or secret is not configured"
		return
	}

	[ -n "$require_message_auth" ] && [ "$require_message_auth" -eq 1 ] && additional="$additional require_message_authenticator"

	echo "$server:$port $secret $timeout" > "${RADIUS_DIR}/${sec}"
	chown pamd:pamd "${RADIUS_DIR}/${sec}"
	eval "$var=\"conf=${RADIUS_DIR}/${sec}${additional}\""
}

tacplus_pam_conf() {
	local var="$1" sec="$2" external_users="$3"
	local server key service additional

	config_get service "$sec" service
	config_get server "$sec" server
	config_get key "$sec" secret
	config_get port "$sec" port

	[ -z "$server" ] || [ -z "$key" ] && {
		logger -t pam "TACACS+ server ip or key is not configured"
		return
	}

	[ -z "$port" ] || {
		server="$server:$port"
	}

	[ "$external_users" -eq 1 ] && {
		case "$service" in
			sshd)
				additional="$additional service=shell"
				;;
			*)
				additional="$additional service=login"
				;;
		esac
	}

	eval "$var=\"server=${server} secret=${key}${additional}\""
}

start_pam_cb() {
	local sec="$1"
	local module type enabled service extra
	local account=0
	local external_users=0

	config_get enabled "$sec" enabled
	[ "$enabled" != "1" ] && return

	ENABLED=1
	
	config_get type "$sec" type
	config_get module "$sec" module
	config_get service "$sec" service
	[ -z "$type" ] || [ -z "$module" ] || [ -z "$service" ] && return

	case "$service" in
		rpcd)
			local pam_all_users="$(uci -q get rpcd.@rpcd[0].pam_all_users)"
			[ "$pam_all_users" == "1" ] && external_users=1
			;;
		sshd)
			local pam_privilege_lvl="$(uci -q get dropbear.@dropbear[0].pam_privilege_lvl)"
			[ -n "$pam_privilege_lvl" ] && [ "$pam_privilege_lvl" -gt 0 ] && external_users=1
			;;
	esac

	[ -f "${PAM_DIR}/${service}" ] || \
		echo "account required pam_permit.so" > "${PAM_DIR}/${service}"

	case $module in
		radius_auth)
			radius_pam_conf extra "$sec" "$external_users"
			;;
		tacplus)
			tacplus_pam_conf extra "$sec" "$external_users"
			[ "$external_users" -eq 1 ] && account=1
			;;
		unix)
			extra="try_first_pass"
			;;
	esac

	echo "auth ${type} pam_${module}.so ${extra}" >> "${PAM_DIR}/${service}"
	[ "$account" -eq 1 ] && \
		echo "account ${type} pam_${module}.so ${extra}" >> "${PAM_DIR}/${service}"
	chown pamd:pamd "${PAM_DIR}/${service}"
}

service_triggers()
{
	procd_add_reload_trigger pam dropbear rpcd
}

start_service() {
	config_load pam

	[ ! -d "$PAM_DIR" ] && cp -af /etc/pam.d "$PAM_DIR"

	config_foreach start_pam_cb pam
	[ "$ENABLED" -eq 1 ] || return 0

	procd_open_instance
	procd_set_param command $PROG
	procd_set_param stdout 1
	procd_set_param stderr 1
	procd_set_param user pamd
	procd_close_instance
}

stop_service() {
	rm -rf "$PAM_DIR"
}

reload_service() {
	stop
	start
}
