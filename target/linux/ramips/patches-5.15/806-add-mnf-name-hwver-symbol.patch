Index: linux-5.15.159/drivers/of/base.c
===================================================================
--- linux-5.15.159.orig/drivers/of/base.c
+++ linux-5.15.159/drivers/of/base.c
@@ -28,6 +28,7 @@
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/proc_fs.h>
+#include <linux/init.h>
 
 #include "of_private.h"
 
@@ -56,6 +57,28 @@ DEFINE_MUTEX(of_mutex);
  */
 DEFINE_RAW_SPINLOCK(devtree_lock);
 
+
+char mnf_device_name[16] __initdata = "";
+char mnf_device_hwver[16] __initdata = "";
+
+static int __init mnf_device_setup(char *str)
+{
+	if (str) {
+		strlcpy(mnf_device_name, str, sizeof(mnf_device_name));
+	}
+	return 1;
+}
+__setup("device=", mnf_device_setup);
+
+static int __init mnf_hwver_setup(char *str)
+{
+	if (str) {
+		strlcpy(mnf_device_hwver, str, sizeof(mnf_device_hwver));
+	}
+	return 1;
+}
+__setup("hwver=", mnf_hwver_setup);
+
 bool of_node_name_eq(const struct device_node *np, const char *name)
 {
 	const char *node_name;
@@ -579,6 +602,51 @@ int of_machine_is_compatible(const char
 }
 EXPORT_SYMBOL(of_machine_is_compatible);
 
+bool of_mnf_hwver_is_compatible(u32 hwver_lower, u32 hwver_upper) {
+	u32 hwver_mnf = 0;
+
+	if (strlen(mnf_device_hwver) < 4) {
+		return false;
+	}
+
+	if (kstrtouint(mnf_device_hwver, 10, &hwver_mnf)) {
+		pr_info("Invalid tlt-mnf,hwver for dts node\n"); // Should never happen
+		return false;
+	}
+
+	if (hwver_mnf > 100) {
+		hwver_mnf = hwver_mnf / 100;
+	}
+
+	if (hwver_lower > hwver_mnf || hwver_upper < hwver_mnf) {
+		return false;
+	}
+
+	return true;
+}
+
+bool of_mnf_name_is_compatible(const struct property *prop) {
+	size_t l;
+	int i;
+	const char *p, *end;
+
+	if (!prop->value)
+		return false;
+
+	p = prop->value;
+	end = p + prop->length;
+
+	for (i = 0; p < end; i++, p += l) {
+		l = strnlen(p, end - p) + 1;
+		if (p + l > end)
+			return false;;
+		if (strstr(mnf_device_name, p))
+			return true; /* Found it */
+	}
+	return false;
+}
+EXPORT_SYMBOL(of_mnf_name_is_compatible);
+
 /**
  *  __of_device_is_available - check if a device is available for use
  *
@@ -589,12 +657,28 @@ EXPORT_SYMBOL(of_machine_is_compatible);
  */
 static bool __of_device_is_available(const struct device_node *device)
 {
+	const struct property *prop_name;
+	const struct property *prop_hwver;
 	const char *status;
 	int statlen;
+	u32 hwver_lower, hwver_upper;
 
 	if (!device)
 		return false;
 
+	prop_name = __of_find_property(device, "tlt-mnf,device" , NULL);
+	if (prop_name && !of_mnf_name_is_compatible(prop_name)) {
+		return false;
+	}
+
+	prop_hwver = __of_find_property(device, "tlt-mnf,hwver" , NULL);
+	if (prop_hwver && !of_property_read_u32_index(device, "tlt-mnf,hwver", 0, &hwver_lower)
+		&& !of_property_read_u32_index(device, "tlt-mnf,hwver", 1, &hwver_upper)) {
+		if (!of_mnf_hwver_is_compatible(hwver_lower, hwver_upper)) {
+			return false;
+		}
+	}
+
 	status = __of_get_property(device, "status", &statlen);
 	if (status == NULL)
 		return true;
Index: linux-5.15.159/include/linux/of.h
===================================================================
--- linux-5.15.159.orig/include/linux/of.h
+++ linux-5.15.159/include/linux/of.h
@@ -412,6 +412,8 @@ extern int of_update_property(struct dev
 extern int of_attach_node(struct device_node *);
 extern int of_detach_node(struct device_node *);
 
+extern bool of_mnf_name_is_compatible(const struct property *prop);
+
 #define of_match_ptr(_ptr)	(_ptr)
 
 /*
