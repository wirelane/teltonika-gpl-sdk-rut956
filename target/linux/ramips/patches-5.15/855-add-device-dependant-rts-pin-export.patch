--- a/drivers/tty/serial/8250/8250_port.c
+++ b/drivers/tty/serial/8250/8250_port.c
@@ -2219,6 +2219,18 @@ int serial8250_do_startup(struct uart_po
 	unsigned long flags;
 	unsigned char lsr, iir;
 	int retval;
+	struct mctrl_gpios *gpios;
+
+	if (port->rs485.flags & SER_RS485_ENABLED &&
+		!mctrl_rts_gpio_is_exported(port->dev, up->gpios)) {
+
+		gpios = mctrl_init_rts_gpio(&up->port);
+		if (IS_ERR(gpios)) {
+			dev_err(port->dev, "Failed to export RTS GPIO on open\n");
+		} else {
+			up->gpios = gpios;
+		}
+	}
 
 	if (!port->fifosize)
 		port->fifosize = uart_config[port->type].fifo_size;
--- a/drivers/tty/serial/serial_mctrl_gpio.c
+++ b/drivers/tty/serial/serial_mctrl_gpio.c
@@ -13,6 +13,7 @@
 #include <linux/serial_core.h>
 #include <linux/module.h>
 #include <linux/property.h>
+#include <linux/gpio.h>
 
 #include "serial_mctrl_gpio.h"
 
@@ -42,6 +43,71 @@ static bool mctrl_gpio_flags_is_dir_out(
 	return mctrl_gpios_desc[idx].flags & GPIOD_FLAGS_BIT_DIR_OUT;
 }
 
+static int get_gpio_by_name(const char *gpio_name)
+{
+	struct gpio_chip *gc = NULL;
+	int chip_index = 0, gpio;
+	while ((gc = gpiochip_find_by_id(chip_index))) {
+		gpio = tlt_gpio_get_line_by_name(gc, gpio_name);
+		if (gpio >= 0) {
+			return gpio + gc->base;
+		}
+		chip_index++;
+	}
+	return -EINVAL;
+}
+
+static void devm_gpio_desc_release(void *desc)
+{
+	gpiod_put((struct gpio_desc *)desc);
+}
+
+struct mctrl_gpios *mctrl_init_rts_gpio(struct uart_port *port) {
+	struct mctrl_gpios *gpios;
+	int gpio_idx;
+
+	gpios = devm_kzalloc(port->dev, sizeof(*gpios), GFP_KERNEL);
+	if (!gpios)
+		return ERR_PTR(-ENOMEM);
+
+	gpio_idx = get_gpio_by_name("GPIO_RS485_D_EN");
+	gpios->gpio[UART_GPIO_RTS] = gpio_to_desc(gpio_idx);
+	if (!gpios->gpio[UART_GPIO_RTS]) {
+		dev_err(port->dev, "Failed to get GPIO descriptor for GPIO %d\n", gpio_idx);
+		return ERR_PTR(-ENODEV);
+	}
+
+	// Release GPIO descriptor when device is removed
+	if (devm_add_action_or_reset(port->dev, devm_gpio_desc_release, gpios->gpio[UART_GPIO_RTS])) {
+		dev_err(port->dev, "Failed to register devm cleanup for GPIO %d\n", gpio_idx);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	if(gpio_request(gpio_idx, "rts")) {
+		dev_err(port->dev,"Failed to request GPIO %d\n", gpio_idx);
+		return ERR_PTR(-EBUSY);
+	}
+
+	if (gpiod_direction_output(gpios->gpio[UART_GPIO_RTS], 0)) {
+		dev_err(port->dev, "Failed to set GPIO %d as output\n", gpio_idx);
+		return ERR_PTR(-EIO);
+	}
+	gpios->port = port;
+	return gpios;
+}
+EXPORT_SYMBOL_GPL(mctrl_init_rts_gpio);
+
+bool mctrl_rts_gpio_is_exported(struct device *dev, struct mctrl_gpios *gpios)
+{
+	if(device_property_present(dev, "rts-gpios"))
+		return true;
+	if (!gpios || !gpios->gpio[UART_GPIO_RTS])
+		return false;
+
+	return desc_to_gpio(gpios->gpio[UART_GPIO_RTS]) >= 0;
+}
+EXPORT_SYMBOL_GPL(mctrl_rts_gpio_is_exported);
+
 void mctrl_gpio_set(struct mctrl_gpios *gpios, unsigned int mctrl)
 {
 	enum mctrl_gpio_idx i;
--- a/drivers/tty/serial/serial_mctrl_gpio.h
+++ b/drivers/tty/serial/serial_mctrl_gpio.h
@@ -57,6 +57,16 @@ struct gpio_desc *mctrl_gpio_to_gpiod(st
 				      enum mctrl_gpio_idx gidx);
 
 /*
+ * Init rts-gpio using tlt-gpio line names
+ */
+struct mctrl_gpios *mctrl_init_rts_gpio(struct uart_port *port);
+
+ /*
+ * Check if rts-gpio exported
+ */
+bool mctrl_rts_gpio_is_exported(struct device *dev, struct mctrl_gpios *gpios);
+
+/*
  * Request and set direction of modem control line GPIOs and set up irq
  * handling.
  * devm_* functions are used, so there's no need to call mctrl_gpio_free().
