--- a/drivers/tty/serial/8250/8250_port.c
+++ b/drivers/tty/serial/8250/8250_port.c
@@ -573,6 +573,7 @@ static void serial8250_clear_fifos(struc
 
 static enum hrtimer_restart serial8250_em485_handle_start_tx(struct hrtimer *t);
 static enum hrtimer_restart serial8250_em485_handle_stop_tx(struct hrtimer *t);
+static enum hrtimer_restart serial8250_em485_handle_stop_rts(struct hrtimer *t);
 
 void serial8250_clear_and_reinit_fifos(struct uart_8250_port *p)
 {
@@ -631,11 +632,15 @@ static int serial8250_em485_init(struct
 		     HRTIMER_MODE_REL);
 	hrtimer_init(&p->em485->start_tx_timer, CLOCK_MONOTONIC,
 		     HRTIMER_MODE_REL);
+	hrtimer_init(&p->em485->stop_rts_timer, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
 	p->em485->stop_tx_timer.function = &serial8250_em485_handle_stop_tx;
 	p->em485->start_tx_timer.function = &serial8250_em485_handle_start_tx;
+	p->em485->stop_rts_timer.function = &serial8250_em485_handle_stop_rts;
 	p->em485->port = p;
 	p->em485->active_timer = NULL;
 	p->em485->tx_stopped = true;
+	p->em485->bit_time = 0;
 
 	p->rs485_stop_tx(p);
 
@@ -661,6 +666,7 @@ void serial8250_em485_destroy(struct uar
 		return;
 
 	hrtimer_cancel(&p->em485->start_tx_timer);
+	hrtimer_cancel(&p->em485->stop_rts_timer);
 	hrtimer_cancel(&p->em485->stop_tx_timer);
 
 	kfree(p->em485);
@@ -1452,13 +1458,41 @@ void serial8250_em485_stop_tx(struct uar
 	 */
 	if (!(p->port.rs485.flags & SER_RS485_RX_DURING_TX)) {
 		serial8250_clear_and_reinit_fifos(p);
-
-		p->ier |= UART_IER_RLSI | UART_IER_RDI;
-		serial_port_out(&p->port, UART_IER, p->ier);
 	}
+	p->ier |= UART_IER_RLSI | UART_IER_RDI;
+	serial_port_out(&p->port, UART_IER, p->ier);
+
 }
 EXPORT_SYMBOL_GPL(serial8250_em485_stop_tx);
 
+static enum hrtimer_restart serial8250_em485_handle_stop_rts(struct hrtimer *t)
+{
+	struct uart_8250_em485 *em485 = container_of(t, struct uart_8250_em485,
+			stop_rts_timer);
+	struct uart_8250_port *p = em485->port;
+	unsigned long flags;
+	int ret = HRTIMER_NORESTART;
+
+	serial8250_rpm_get(p);
+	spin_lock_irqsave(&p->port.lock, flags);
+		if (p->port.rs485.delay_rts_after_send == 0) {
+			if ((serial_in(p, UART_LSR) & BOTH_EMPTY) != BOTH_EMPTY) {
+				hrtimer_forward(&em485->stop_rts_timer,
+					hrtimer_cb_get_time(&em485->stop_rts_timer),
+						ktime_set(0, ns_to_ktime(em485->bit_time * 1000))
+				);
+				ret = HRTIMER_RESTART;
+			} else {
+				em485->bit_time = 0;
+				p->rs485_stop_tx(p);
+			}
+		}
+	spin_unlock_irqrestore(&p->port.lock, flags);
+	serial8250_rpm_put(p);
+
+	return ret;
+}
+
 static enum hrtimer_restart serial8250_em485_handle_stop_tx(struct hrtimer *t)
 {
 	struct uart_8250_em485 *em485 = container_of(t, struct uart_8250_em485,
@@ -1512,6 +1546,7 @@ static inline void __do_stop_tx(struct u
 static inline void __stop_tx(struct uart_8250_port *p)
 {
 	struct uart_8250_em485 *em485 = p->em485;
+	unsigned int div;
 
 	if (em485) {
 		unsigned char lsr = serial_in(p, UART_LSR);
@@ -1521,8 +1556,28 @@ static inline void __stop_tx(struct uart
 		 * shift register are empty. It is for device driver to enable
 		 * interrupt on TEMT.
 		 */
-		if ((lsr & BOTH_EMPTY) != BOTH_EMPTY)
+		if ((lsr & BOTH_EMPTY) != BOTH_EMPTY) {
+			if (em485->bit_time == 0) {
+				unsigned char lcr = serial_in(p, UART_LCR);
+
+				serial_out(p, UART_LCR, lcr | UART_LCR_DLAB);
+				div = ((unsigned int)(serial_in(p, UART_DLM)) << 8);
+				div |= serial_in(p, UART_DLL);
+				serial_out(p, UART_LCR, lcr);
+
+				em485->bit_time = (div * 4) / 10; //time of one bit
+
+				hrtimer_start(&em485->stop_rts_timer,
+					ns_to_ktime(em485->bit_time * 1000)	, HRTIMER_MODE_REL);
+
+				/* workaround: there is no irq on TEMT in MT76x8.
+				 * To detect shift register finish tx last bit
+				 * do check of TEMT bit by using timer after
+				 * last byte was loaded to shift register
+				 * */
+			}
 			return;
+		}
 
 		__stop_tx_rs485(p);
 	}
@@ -1795,6 +1850,7 @@ EXPORT_SYMBOL_GPL(serial8250_rx_chars);
 void serial8250_tx_chars(struct uart_8250_port *up)
 {
 	struct uart_port *port = &up->port;
+	struct uart_8250_em485 *em485 = up->em485;
 	struct circ_buf *xmit = &port->state->xmit;
 	int count;
 
@@ -1811,6 +1867,11 @@ void serial8250_tx_chars(struct uart_825
 		return;
 	}
 
+	if(em485) {
+		if (up->port.rs485.delay_rts_before_send == 0)
+			up->rs485_start_tx(up);
+	}
+
 	count = up->tx_loadsz;
 	do {
 		serial_out(up, UART_TX, xmit->buf[xmit->tail]);
@@ -2032,6 +2093,9 @@ EXPORT_SYMBOL_GPL(serial8250_do_set_mctr
 
 static void serial8250_set_mctrl(struct uart_port *port, unsigned int mctrl)
 {
+	if (port->rs485.flags & SER_RS485_ENABLED)
+		return;
+
 	if (port->set_mctrl)
 		port->set_mctrl(port, mctrl);
 	else
--- a/include/linux/serial_8250.h
+++ b/include/linux/serial_8250.h
@@ -79,9 +79,11 @@ struct uart_8250_ops {
 struct uart_8250_em485 {
 	struct hrtimer		start_tx_timer; /* "rs485 start tx" timer */
 	struct hrtimer		stop_tx_timer;  /* "rs485 stop tx" timer */
+	struct hrtimer		stop_rts_timer; /* "rs485 stop rts" timer 	*/
 	struct hrtimer		*active_timer;  /* pointer to active timer */
 	struct uart_8250_port	*port;          /* for hrtimer callbacks */
 	unsigned int		tx_stopped:1;	/* tx is currently stopped */
+	unsigned long		bit_time;	/* for holding bit time */
 };
 
 /*
